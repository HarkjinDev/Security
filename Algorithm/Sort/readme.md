# Sort Algorithm

## Bubble Sort(버블 정렬)
- 인접한 두 개의 원소를 비교하여 크기가 순서대로 되어 있지 않으면 이들을 서로 교환하는 정렬 방식
- 메모리 사용공간 : n개의 원소에 대하여 n개의 메모리 사용
- 평균 시간 복잡도 : O(n^2)

## Selection Sort(선택 정렬)
- 전체 자료 중 최소값을 찾아 첫 번째 위치에 놓고 나머지 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식
- 메모리 사용공간 : n개의 원소에 대하여 n개의 메모리 사용
- 시간 복잡도 : O(n^2)

## Insert Sort(삽입 정렬)
- 대상 자료가 일부 정렬되어 있을 때 유리한 정렬 방식으로 선택(기준)된 키 값을 앞쪽 자료들의 키 값과 비교하여 자신의 위치를 찾아 삽입 정렬시키는 방식
- 문제점 : 요소들이 삽입될 때, 이웃한 위치로만 이동

## Shell Sort(셸 정렬)
- 일정한 간격(INTERVAL)으로 떨어져 있는 자료들끼리 부분집합을 구성하고 각 부분집합에 있는 원소들에 대해서 삽입 정렬을 수행하는 작업을 반복하면서 전체 원소들을 정렬하는 방법
- 평균 시간 복잡도 : O(n^1.5)
- 요소들이 멀리 떨어진 위치로도 이동할 수 있다.

## Merge-Sort(병합 정렬)
- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 정렬 방법
- 평균 시간 복잡도 : O(nlog2n)

## Quick Sort(퀵 정렬)
- 정렬할 전체 원소에 대해서 정렬을 수행하지 않고, 기준 값을 중심으로 왼쪽 부분 집합과 오른쪽 부분 집합으로 분할하여 정렬하는 방법
- 피봇(pivot) : 기준 값
- 분할(divide) : 정렬할 자료들을 기준값을 중심으로 2개의 부분 집합으로 분할한다.\
- 정복(conquer) : 부분 집합의 원소들 중에서 기준값보다 작은 원소들을 왼쪽 부분 집합으로, 기준값보다 큰 원소들은 오른쪽 부분집합으로 정렬한다. 부분 집합의 크기가 1이하로 충분히 작지 않으면 순환호출을 이용하여 다시 분할한다.

## Heap Sort(히프 정렬)
- 히프에서는 항상 가장 큰 원소가 루트 노드가 되고, 삭제 연산을 수행하면 항상 루트 노드의 원소를 삭제하여 반환
  1. 최대 히프에 대해서 원소의 개수만큼 삭제 연산을 수행하여 내림차순으로 정렬 수행
  2. 최소 히프에 대해서 원소의 개수만큼 삭제 연산을 수행하여 오름차순으로 정렬 수행
- 메모리 사용 공간 : 원소 n개에 대해서 n개의 메모리 공간 사용 + 크기 n의 히프 저장공간
- 평균 시간 복잡도 : O(log2n)

## Radix Sort(기수 정렬)
- 분배 방식의 정렬 방법으로 정렬할 원소의 킷값에 해당하는 버킷(Bucket)에 원소를 분배하였다가 버킷의 순서대로 원소를 꺼내는 방법을 반복한다.
- 원소의 키를 표현하는 값의 기수(Radix)만큼의 버킷이 필요하고, 킥삾의 자릿수만큼 기수 정렬을 반복
- 추가적인 메모리가 필요하지만 빠르기 때문에 상당히 인기.
- 단점 : 정렬할 수 있는 레콛드의 타입이 한정된다는 점. 즉, 레코드의 키들이 동일한 길이를 가지는 숫자나 문자열로 구성되어야 함.
- 평균 시간 복잡도 : O(dn)
