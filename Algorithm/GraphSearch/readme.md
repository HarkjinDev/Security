# GraphSearch

## Adjacency Materix(인접 행렬) - O(N+E)
![adjacency_materix](/Algorithm/GraphSearch/adjacency_materix.png)
- 인접행렬은 그래프의 노드를 2차원 배열로 만든 것
- 완성된 배열의 모양은 1, 2, 3, 4, 5, 6의 정점을 연결하는 노드에 다른 노드들이 인접 정점이라면 1, 아니면 0을 넣음
- 장점
  1) 차원 배열 안에 모든 정점들의 간선 정보를 담기 때문에 배열의 위치를 확인하면 두 점에 대한 연결 정보를 조회할 때 O(1) 의 시간 복잡도면 가능
  2) 구현이 비교적 간단
- 단점
  1) 모든 정점에 대해 간선 정보를 대입해야 하므로 O(n²) 의 시간복잡도가 소요
  2) 무조건 2차원 배열이 필요하기에 필요 이상의 공간이 낭비

## Adjacency List(인접 리스트) - O(N²)
![adjacency_list](/Algorithm/GraphSearch/adjacency_list.png)
- 그래프의 노드들을 리스트로 표현한것
- 주로 정점의 리스트 배열을 만들어 관계를 설정해줌으로써 구현
- 장점
  1) 정점들의 연결 정보를 탐색할 때 O(n) 의 시간이면 가능 (n: 간선의 갯수)
  2) 필요한 만큼의 공간만 사용하기때문에 공간의 낭비가 적음
- 단점
  1) 특정 두 점이 연결되었는지 확인하려면 인접행렬에 비해 시간이 오래 걸림 (배열보다 search 속도느림)
  2) 구현이 비교적 어렵다.

## DFS(Depth First Search, 깊이 우선 탐색)
- 루트 노드나 임의의 노드에서 시작하여 최대로 진입할 수 잇는 깊이까지 탐색한 후 돌아와 다른 노드로 탐색하는 방식
- Stack을 활용
- 재귀함수로 사용 가능
- 장점
  1) 현 경로상의 노드들만 기억하면 되므로 저장공간 수요가 비교적 적음
  2) 목표 노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있음
- 단점
  1) 해가 없는 경로가 깊을 경우 탐색시간이 오래 걸릴 수 있음
  2) 얻어진 해가 최단 경로가 된다는 보장이 없음

## BFS(Breadth Frist Search, 너비 우선 탐색)
- 루트 노드나 임의의 노드에서 시작하여 인접한 노드를 먼저 모두 확인한 후 다음 depth를 탐색
- Queue를 사용
- 특징
  1) 시작 정점부터 거리가 가까운 정점의 순서로 탐색
  2) 재귀적으로 동작하지 않음
  3) FIFO 원칙으로 탐색

## DFS vs BFS
![graphsearch](/Algorithm/GraphSearch/graphsearch.gif)
- 모든 정점 방문 : DFS나 BFS 동일
- 경로의 특징을 둘 때 : DFS
- 최단거리 : BFS가 유리
- 검색 대상이 크다면 : DFS 고려
- 검색 대상이 크지 않고, 대상이 별로 멀지 않다면 : BFS 고려
